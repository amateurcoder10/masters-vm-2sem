#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <signal.h>
#include <string.h>
#include <errno.h>

void *signal_thread (void *arg);

static sigset_t   signal_mask;  /* signals to block         */


int main (int argc, char *argv[])
{
    pthread_t  sig_thr_id;      /* signal handler thread ID */
    int        rc;              /* return code              */


    sigemptyset(&signal_mask);//initialises the signal set to an empty one
    sigaddset(&signal_mask, SIGINT);//add to set the sigint--interrupt signal,generated by ctrl+c and sigterm--termination signal
    sigaddset(&signal_mask, SIGTERM);
    rc = pthread_sigmask (SIG_BLOCK, &signal_mask, NULL);//examine and change the mask fo clocked signals;sig_block--set of blocked signals
    if (rc != 0) 
    {
printf("error");
        /* handle error */
    }
    /* any newly created threads inherit the signal mask */


    rc = pthread_create (&sig_thr_id, NULL, signal_thread, NULL);//create a signal handling thread
    if (rc != 0) 
    {
printf("error");
        /* handle error */
    }
	pthread_join(sig_thr_id,NULL);

    /*  OTHER CODE */
}


void *signal_thread (void *arg)
{
    int       sig_caught;    /* signal caught       */
    int       rc;            /* returned code       */

printf("within the thread\n");

    rc = sigwait (&signal_mask, &sig_caught);//blocking call-wait for one of the signals in the mask

    if (rc != 0) 
    {
        /* handle error */
    }
    switch (sig_caught)
    {
    case SIGINT:  
	printf("received SIGINT");   /* process SIGINT  */
        break;
    case SIGTERM:    /* process SIGTERM */
	printf("received SIGTERM");
        break;
    default:         /* should normally not happen */
        fprintf (stderr, "\nUnexpected signal %d\n", sig_caught);
        break;
   }
}
